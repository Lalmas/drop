<?xml version="1.0"?>
<section xmlns="http://docbook.org/ns/docbook" 
	 xmlns:xlink="http://www.w3.org/1999/xlink"
	 xml:id="quality.book">
  <info>
    <title>Source Code Quality</title>
    <date>February 13th, 2010</date>
  </info>
  
  <para>
    The quality of a software system relies fundamentally on dedicated and inventive contributors supported by appropriate procedures and tools. Quality is in many ways subjective. The quality in terms of usefulness relies a lot on trial and errors, the larger software ecosystem, human perceptions and a perfect market timing. There are unlikely mechanical, reliable procedures and infrastructures to achieve this kind of quality. We will focus here on quality that can be mechanically enforced, primarily that software systems behaves as expected by the people who wrote the code. The mechanical enforcement tools fall in two categories: static analysis and run-time behavior. 
  </para>
  <section>
    <title>Conventions</title>
    <para>The purpose of conventions is to make it faster for developers to use pre-existing general knowledge and start contributing to specific projects they were unfamiliar with. Conventions also help create automated tools and an infrastructure to build code, run tests and generate status reports (as detailed in <link linkend="workspace.book">workspace</link>).</para>
    <section>
      <title>Code Layout</title>
    <para>Each project in fortylines source repository is organized as follow</para>
    <variablelist>
      <varlistentry>
	<term>index.xml</term>
	<listitem>
	  <para>Project description and inter-projects dependency information.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>Makefile</term>
	<listitem>
	  <para>GNU Makefile used to build and install a project files on the local system.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>data/</term>
	<listitem><para>Files necessary to build and run project executables but which are not considered source files.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>doc/</term>
	<listitem><para>General documentation for the project which cannot be extracted from the source files.</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>include/</term>
	<listitem><para>Public header files (.hh, .tcc) that are installed in <link linkend="dws.book#includeDir">includeDir</link> (ex. /usr/local/include).</para>
	</listitem>
      </varlistentry>
      <varlistentry>
	<term>src/</term>
	<listitem><para>Source code in the form of C++ (.cc) and Python (.py) files.</para>
	</listitem>
      </varlistentry>
    </variablelist>
    <para>All files in fortylines source repository should respect the following conventions</para>
    <itemizedlist>
      <listitem><para>Each source file starts with a few license paragraphs.</para></listitem>
      <listitem><para>Identifiers use camelCase with a leading lowercase letter.</para></listitem>
      <listitem><para>Each file name follows the camelCase identifier convention.</para></listitem>
    </itemizedlist>
    <para>
      As projects grow in size, it becomes cumbersome to enforce conventions manually. As a result, the only convention that exist are the ones that can be checked and enforce by an automated tool as part of the build process.
    </para>
    <para>
      A checkstyle script runs through the top-level <link linkend="dws.book#srcTop">srcTop</link> and outputs a detailed report about projects broking those conventions.</para>    
    </section>
    <section>
      <title>Release Checklist</title>
      <para>It is not easy to realize when a project is of release quality. Planes do not take off before the captain verify every items on a list and checks them off. It is a very efficient and cost-effective way of insuring a certain level of quality. In the software world, as the cost of post-release workarounds and fixes can become enormous, it is wise to keep a simple, straightforward &quot;release checklist&quot; to thoroughly go through before any package is pushed onto the delivery channels. Having an explicit release checklist is an important step towards a consistent quality through releases. For example:</para>
      <itemizedlist>
	<listitem><para>General</para>
	  <itemizedlist>
	    <listitem><para>All unit tests pass</para></listitem>
	    <listitem><para>All source files have an appropriate license</para></listitem>
	    <!-- Remove hardcoded references (fortylines, "solutions", 
		 smirolo, etc. -->
	  </itemizedlist>
	</listitem>
	<listitem><para>C++ (.hh, .tcc, .cc)</para>
	  <itemizedlist>
	    <listitem><para>No std::cerr statements that can be accounted as debugging messages.</para></listitem>
	    <listitem><para>No "#if 0" nor "#if 1" without a blessed &quot;todo&quot; comment.</para></listitem>
	    <listitem><para>compile with no warnings when using -Wall compiler command line flag</para></listitem>
	  </itemizedlist>
	</listitem>
	<listitem><para>Python (.py)</para>
	  <itemizedlist>
	    <listitem><para>No "if None:" without a blessed &quot;todo&quot; comment.</para></listitem>
	  </itemizedlist>
	</listitem>
	<listitem><para>Documentation (.docbook)</para>
	  <itemizedlist>
	    <listitem><para>No error when run through the spellchecker</para></listitem>
	  </itemizedlist>
	</listitem>
	<listitem><para>HTML (.css, .template)</para>
	  <itemizedlist>
	    <listitem><para>Correct display of each template on Firefox, Safari and IE8.</para></listitem>
	  </itemizedlist>
	</listitem>
      </itemizedlist>
    </section>
  </section>
  
  <section>
    <title>Unit tests</title>
    <para>The purpose of unit tests is to insure first that functionality is implemented correctly. Later in the life cycle of a project, unit tests are often relabeled regression tests and insure that changes to the source code did not break existing functionality.</para>
    <section>
      <title>Functional and regression tests</title>
      <para>The definition of functional and regression tests are very often used interchangeably because a functional test can serve as the base for a regression test as much as a regression test can be used to validate functionality.</para>
    <para>For our purpose here, the major distinction between a functional and regression test is how they were originally created. The developer of a functional test has explicitly thought about the passing and failing conditions and written explicit statements for them in the source code that is checked into the repository. The developer of a regression test typically used the build framework to trigger comparison of different runs of the same program.</para> 
    <para>As such functional tests usually result in source code while regression tests result in makefile rules. Functional tests also typically result in self-contained executables while regression tests rely on external data sets usually stored outside the version controlled repository.</para>
    <informaltable>
      <tr><th>functional</th><th>regression</th></tr>
      <tr><td>explicit pass conditions</td><td>output comparison</td></tr>
      <tr><td>source code</td><td>makefiles</td></tr>
      <tr><td>self-contained</td><td>rely on external data sets</td></tr>
    </informaltable>
    <para> Unit tests will typically start breaking and become deprecated as a project moves forward. As a result, relevant unit tests are the ones that can be run by an automated tool as part of the <link linkend="/contrib/fortylines/doc/usecases.book#snapshotBuilds">build process</link>.</para>
    <para>Regardless of the original specification of a unit test, the web presentation engine provides both a test functional view and a test regression view. Functional views are useful in the release process to validate that tests pass on all systems and configurations. A failing test in the context of a functional view usually indicates an unanticipated error that must be further investigated. Regression views tie a change in behavior to a specific source revision and or system. Regression views will thus be most useful to contributors investigating why a previously passing test started to fail.
    </para>
    </section>
    <section>
      <title>Projects and tests source repositories</title>
      <para>
	There are usually two approaches to store the tests associated to a project. Either they can form a sub-directory in the project hierarchy and managed as part of the same physical repository or they can form their own directory hierarchy and managed in a logically separate repository. Choosing either approach depends on the distribution model. In a typical two-party model made of a developer and a user, the developer provides a source package to the user; the user compiles the code provided, checks the stability of it and installs it on the system. In a typical three-party model made of a developer, a distributor and a user, the developer provides a source package to the distributor; the distributor compiles the code provided, checks the stability of it and provides a binary package to the user; the user then updates the system and installs the binary package as a side effect.
      </para>
	<informaltable>
	  
<tr><td><programlisting># Two-party model</programlisting></td>    
  <td><programlisting># Three-party model</programlisting></td></tr>
	
<tr><td><programlisting># developer                      
make dist-src</programlisting></td>       
<td><programlisting># developer
make dist-src</programlisting></td></tr>

<tr><td></td>	                  
<td><programlisting># distributor
cd project-test
tar zxvf project.tar.gz
make
make dist</programlisting></td></tr>

<tr><td><programlisting># user                            
tar zxvf project.tar.gz           
cd project
./configure
make
make check
make install</programlisting></td>        
<td><programlisting># user (ex. Ubuntu)
apt-get install project</programlisting></td></tr>
	</informaltable>    
      <para>
	In a two-party model, including tests as a sub-directory in the project repository seems more appropriate. It facilitates the life of the developer to deal with a single repository and distribute tests along the project into a single package. The end-user can also rely on a single source package and a straightforward procedure to deploy a project on the system.
      </para>
      <para>
	In a three-party model, dual repositories approach for project and tests is better suited then. The test repository can be relatively large with regards to the project repository itself and of little use for anyone but the distributor. Furthermore the responsibility of writing and running tests have been off loaded to the distributor so it is usually more practical for the distributor to maintain its own tests repository separate from the developer project repository.
      </para>
      <para>
	Fortylines uses the dual repositories approach. The tests for a project form their own repository in a separate directory hierarchy. The organization of a test project though follows the organization of a regular project directory consisting of Makefile, src/ and data/, etc. directories. Thus project and tests are purely a distribution policy difference and the workspace management tools are agnostic of that difference.
      </para>
  </section>
    </section>
</section>

