<?xml version="1.0"?>
<section xmlns="http://docbook.org/ns/docbook" 
	 xmlns:xlink="http://www.w3.org/1999/xlink">
<section>		
<title>Access Control</title>
<section>
<title>Policy</title>
<para>
Before you can deploy technology to support access control of your machine, you need a clear answer to the following questions because you might not want to put secure locks on each door of the house while you keep your valuables in the garage.
</para>
<simplelist>
<member>Purpose of the machine.</member>
<member>Evaluation of damages of a compromised machine.</member>
<member>Which individual is allowed to read and write which file on the machine.</member>
</simplelist>
</section>
<section>
<title>Partitioning</title>
<para>
One of the first principle of controlling information is partitioning. For example, a same person will have different passwords for different roles and systems. Partitioning restricts compromised information to a specific subsystem.
</para>
</section>
<section xml:id="Auditing">
<title>Auditing</title>
<para>
It is better to discover and address a vulnerability before taken advantage of by an unauthorized party. Active penetration auditing sets the time it takes to compromise a system. Password cracking tool, for example, should continuously be run against password files, because no matter how complex a password policy is, only actual time to crack the first password matters.
</para>
<para>
Another category of auditing tools focus on intrusion detection. This sets the delay between a system being actually compromised and the intrusion detected. Activity logging and analysis are a big part of this kind of auditing.
</para>
<!-- \todo temper resistance section -->
</section>
<section>
<title>Physical Access</title>
<para>
Passwords, file permissions, firewalls, etc. do not prevent against unauthorized accesses to a physical infrastructure. Stolen laptops form a majority of unauthorized physical access. Encryption of the persistent data is the only way to prevent access to controlled information in that case. As most applications use temporary files and generate data caches at different random places on a harddrive, only full disc encryption at the device level guarantees information is actually stored encrypted.  
</para>
</section>
<section>
<title>Remote Access</title>
<para>
The same way encryption is used for preventing unauthorized physical access to information stored on a disk, it can be used in communication protocols to prevent eavesdropping. The most commonly used set of tools for that purpose is the <link xlink:href="http://www.openssh.com/">openssh</link> software package.
</para>
<para>
A remote machine provides services on open ports. Since each open ports is potentially a vector of attacks, the most tighten access control policy is to only have one port publicly open for the openssh daemon and use the local forward mechanism to redirect traffic to other services.
</para>
</section>

<section xml:id="authentication">
<title>Authentication</title>
<para>
Users have restricted permissions to access files and services. Authentication consists for a system to verify a user is who he claims to be. In every day life, you might be asked to present your driver's licence before you can access your bank account. This is authentication. Usually, pieces of information to provide the system to authenticate fall in one of the following categories:
<simplelist>
<member><emphasis>What you know</emphasis>, for example, a password</member>
<member><emphasis>What you have</emphasis>, for example, a key</member>
<member><emphasis>What you are</emphasis>, for example, a fingerprint</member>
</simplelist>
</para>
<para>
On today computer systems, public/private key cryptography is concidered one of the most sure way of authentication and thus heavily used. ssh and gpg, both, use public/private keys for authentication. Keys are typically very long and thus a shorter fingerprint is usually used to validate the authenticity of the key itself. To obtain fingerprints for ssh and gpg keys, use the following commands respectively.
</para>
<para role="code">
ssh-keygen -lf <emphasis>keyfile</emphasis>
gpg --fingerprint <emphasis>username</emphasis>
</para>
<para>
Each service typically came with its own custom-built authentication mechanism. That not only increased the risk of a system to be compromised but also created management headaches for IT staffs. In Linux, slowing <link xlink:href="http://www.installationwiki.org/PAM">PAM</link> as emerged as a unifying standard for authentication. Each service that cares about authentication can use <link xlink:href="http://www.packtpub.com/article/development-with-pluggable-authentication-modules-pam">PAM's simple programming interface</link> to leverage a well-behaved authentication library. 
</para>
</section>
<!--
\todo:
	#1 Harddrive encryption
	#2 ssh tunnels
	#3 PGP signed e-mails?
	#4 automated audits of touched files, open ports, etc.
-->
</section>
</section>
